# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2018, Zalando SE
# This file is distributed under the same license as the Connexion package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
msgid ""
msgstr ""
"Project-Id-Version: Connexion 2.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-03-29 15:28+0900\n"
"PO-Revision-Date: 2019-04-22 11:37+0900\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"
"Last-Translator: \n"
"Language-Team: \n"
"Language: ko\n"
"X-Generator: Poedit 2.2.1\n"

#: ../../security.rst:2
msgid "Security"
msgstr "보안"

#: ../../security.rst:5
msgid "OAuth 2 Authentication and Authorization"
msgstr "OAuth 2 인증과 권한"

#: ../../security.rst:7
msgid ""
"Connexion supports one of the three OAuth 2 handling methods. With "
"Connexion, the API security definition **must** include a ``x-"
"tokenInfoFunc`` or set ``TOKENINFO_FUNC`` env var."
msgstr ""
"Connexion은 세가지 OAuth2 처리 방법 중 하나를 지원한다. Connexion을 사용"
"하면 **반드시** API 보안 정의에 ``x-tokenInfoFunc``\\ 를 포함하거나 "
"``TOKENINFO_FUNC`` 환경변수를 설정해야 한다."

#: ../../security.rst:11
msgid ""
"``x-tokenInfoFunc`` must contain a reference to a function used to "
"obtain the token info. This reference should be a string using the same "
"syntax that is used to connect an ``operationId`` to a Python function "
"when routing. For example, an ``x-tokenInfoFunc`` of ``auth."
"verifyToken`` would pass the user's token string to the function "
"``verifyToken`` in the module ``auth.py``. The referenced function "
"accepts a token string as argument and should return a dict containing a "
"``scope`` field that is either a space-separated list or an array of "
"scopes belonging to the supplied token. This list of scopes will be "
"validated against the scopes required by the API security definition to "
"determine if the user is authorized. You can supply a custom scope "
"validation func with ``x-scopeValidateFunc`` or set "
"``SCOPEVALIDATE_FUNC`` env var, otherwise ``connexion.decorators."
"security.validate_scope`` will be used as default."
msgstr ""
"``x-tokenInfoFunc``\\ 은 토큰 정보를 가져오는 함수에 대한 참조를 포함한"
"다. 이 참조는 라우팅할 때 ``operationId``\\ 를 파이썬 함수에 연결하는데 "
"사용되는 것과 동일한 문법을 사용한 문자열이어야 한다. 예를 들어, ``auth."
"verifyToken``\\ 의 ``x-tokenInfoFunc``\\ 은 사용자의 토큰 문자열을 "
"``auth.py`` 모듈의 ``verifyToken`` 함수에 전달한다. 참조된 함수는 토큰 문"
"자열을 인수로 받고, 공백으로 구분된 리스트나 제공된 토큰에 포함된 범위"
"(scopes)의 배열인 ``scope`` 필드를 포함하는 딕셔너리를 반환한다. 이 범위 "
"리스트는 유효성이 검사된다. 검사는 API 보안 정의에서 사용자에게 권한이 있"
"는지 결정하는 데 필요한 범위에 대해 진행된다. ``x-scopeValidateFunc``\\ "
"나 ``SCOPEVALIDATE_FUNC`` 환경 변수를 설정해서 사용자 정의 범위 유효성 검"
"사 함수를 제공할 수 있다. 기본적으로는 ``connexion.decorators.security."
"validate_scope``\\ 가 사용된다."

#: ../../security.rst:26
msgid ""
"The recommended approach is to return a dict which complies with `RFC "
"7662 <rfc7662_>`_. Note that you have to validate the ``active`` or "
"``exp`` fields etc. yourself."
msgstr ""
"권장되는 방식은 `RFC 7662 <rfc7662_>`_\\ 를 따르는 딕셔너리를 반환하는 "
"것이다. ``active``\\ 나 ``exp`` 필드 등의 유효성을 직접 검사해야 함을 유"
"의해라."

#: ../../security.rst:30
msgid ""
"The ``sub`` property of the Token Info response will be passed in the "
"``user`` argument to the handler function."
msgstr ""
"Token Info 응답의 ``sub`` 속성은 핸들러 함수에 대한 ``user`` 인수에 전달"
"될 것이다."

#: ../../security.rst:33
msgid "Deprecated features, retained for backward compability:"
msgstr "이전 버전과의 호환을 위해 남아있지만 사용하지 않는 기능:"

#: ../../security.rst:35
msgid ""
"As alternative to ``x-tokenInfoFunc``, you can set ``x-tokenInfoUrl`` or "
"``TOKENINFO_URL`` env var. It must contain a URL to validate and get the "
"token information which complies with `RFC 6749 <rfc6749_>`_. When both "
"``x-tokenInfoUrl`` and ``x-tokenInfoFunc`` are used, Connexion will "
"prioritize the function method. Connexion expects the authorization "
"server to receive the OAuth token in the ``Authorization`` header field "
"in the format described in `RFC 6750 <rfc6750_>`_ section 2.1. This "
"aspect represents a significant difference from the usual OAuth flow."
msgstr ""
"``x-tokenInfoFunc`` 대신 ``x-tokenInfoUrl``\\ 나 ``TOKENINFO_URL`` 환경변"
"수를 설정할 수 있다. 유효성을 검사하고 `RFC 6749 <rfc6749_>`_\\ 을 따르"
"는 토큰 정보를 얻으려면 URL을 포함해야 한다. ``x-tokenInfoUrl``\\ 과 ``x-"
"tokenInfoFunc``\\ 이 모두 사용되면, Connexion은 함수 메소드의 우선 순위"
"를 정한다. Connexion은 권한 부여 서버가 `RFC 6750 <rfc6750_>`_ 섹션 2.1"
"에 기술된 형식으로 ``Authorization`` 헤더 필드에 OAuth 토큰을 받기를 기대"
"한다. 이 측면에서 일반적인 OAuth와 큰 차이가 있다."

#: ../../security.rst:43
msgid "``scope`` field can also be named ``scopes``."
msgstr "``scope`` 필드는 ``scopes``\\ 라고도 명명될 수 있다."

#: ../../security.rst:44
msgid "``sub`` field can also be named ``uid``."
msgstr "``sub`` 필드는 ``uid``\\ 라고 명명될 수도 있다."

#: ../../security.rst:46
msgid ""
"You can find a `minimal OAuth example application`_ in Connexion's "
"\"examples\" folder."
msgstr ""
"Connexion의 `examples` 폴더에서 `minimal OAuth example application`_\\ "
"를 볼 수 있다."

#: ../../security.rst:50
msgid "Basic Authentication"
msgstr "기본 인증"

#: ../../security.rst:52
msgid ""
"With Connexion, the API security definition **must** include a ``x-"
"basicInfoFunc`` or set ``BASICINFO_FUNC`` env var. It uses the same "
"semantics as for ``x-tokenInfoFunc``, but the function accepts three "
"parameters: username, password and required_scopes. If the security "
"declaration of the operation also has an oauth security requirement, "
"required_scopes is taken from there, otherwise it's None. This allows "
"authorizing individual operations with oauth scope while using basic "
"authentication for authentication."
msgstr ""
"Connexion을 사용하면, **반드시** API 보안 정의에 ``x-basicInfoFunc``\\ "
"을 포함하거나 ``BASICINFO_FUNC`` 환경 변수를 설정해야 한다. ``x-"
"tokenInfoFunc``\\ 와 동일한 의미론을 사용하지만, 함수는 세가지 파라미터"
"(username, password, required_scopes)를 받는다. 작업의 보안 선언에도 "
"oauth 보안 요구가 있는 경우, `required_scopes`\\ 는 거기에서 가져와지고, "
"없는 경우에는 `None`\\ 이다. 따라서 기본 인증을 사용할 때 oauth 범위로 개"
"별 작업에 대한 인증을 할 수 있다."

#: ../../security.rst:61
msgid ""
"You can find a `minimal Basic Auth example application`_ in Connexion's "
"\"examples\" folder."
msgstr ""
"Connexion의 `examples` 폴더에서 `minimal Basic Auth example "
"application`_\\ 을 볼 수 있다."

#: ../../security.rst:64
msgid "ApiKey Authentication"
msgstr "ApiKey 인증"

#: ../../security.rst:66
msgid ""
"With Connexion, the API security definition **must** include a ``x-"
"apikeyInfoFunc`` or set ``APIKEYINFO_FUNC`` env var. It uses the same "
"semantics as for ``x-basicInfoFunc``, but the function accepts two "
"parameters: apikey and required_scopes."
msgstr ""
"Connexion을 사용하면 API 보안 정의는 **반드시** ``x-apikeyInfoFunc``\\ "
"을 포함하거나, ``APIKEYINFO_FUNC`` 환경변수를 설정해야 한다. ``x-"
"basicInfoFunc``\\ 과 동일한 의미론을 가지나, 함수는 두 개의 파라미터"
"(apikey, required_scopes)를 받는다."

#: ../../security.rst:71
msgid ""
"You can find a `minimal API Key example application`_ in Connexion's "
"\"examples\" folder."
msgstr ""
"Connexion의 `examples` 폴더에서 `minimal API Key example application`_"
"\\ 을 볼 수 있다."

#: ../../security.rst:74
msgid "Bearer Authentication (JWT)"
msgstr "Bearer 인증 (JWT)"

#: ../../security.rst:76
msgid ""
"With Connexion, the API security definition **must** include a ``x-"
"bearerInfoFunc`` or set ``BEARERINFO_FUNC`` env var. It uses the same "
"semantics as for ``x-tokenInfoFunc``, but the function accepts one "
"parameter: token."
msgstr ""
"Connexion을 사용하면, API 보안 정의는 **반드시** ``x-bearerInfoFunc``\\ "
"을 포함하거나, ``BEARERINFO_FUNC`` 환경변수를 설정해야 한다. ``x-"
"tokenInfoFunc``\\ 과 동일한 의미론으로 사용하지만 함수는 하나의 파라미터"
"(token)를 받는다."

#: ../../security.rst:80
msgid ""
"You can find a `minimal JWT example application`_ in Connexion's "
"\"examples/openapi3\" folder."
msgstr ""
"Connexion의 `examples/openapi3` 폴더에서 `minimal JWT example "
"application`_\\ 을 볼 수 있다."

#: ../../security.rst:83
msgid "HTTPS Support"
msgstr "HTTPS 지원"

#: ../../security.rst:85
msgid ""
"When specifying HTTPS as the scheme in the API YAML file, all the URIs "
"in the served Swagger UI are HTTPS endpoints. The problem: The default "
"server that runs is a \"normal\" HTTP server. This means that the "
"Swagger UI cannot be used to play with the API. What is the correct way "
"to start a HTTPS server when using Connexion?"
msgstr ""
"API YAML 파일 스키마로 HTTPS를 지정할 때, 제공된 Swagger UI의 모든 URI는 "
"HTTPS 엔드포인드다. 문제: 실행하는 기본 서버가 “일반적인” HTTP 서버다. "
"즉, API를 실행해 볼 때 Swagger UI를 사용할 수 없다. Connexion을 통해 "
"HTTPS 서버를 시작할 때 올바른 방법은 무엇일까?"
