# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2018, Zalando SE
# This file is distributed under the same license as the Connexion package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2019.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Connexion 2.0\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-03-29 15:28+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../../response.rst:2
msgid "Response Handling"
msgstr "응답 처리"

#: ../../response.rst:5
msgid "Response Serialization"
msgstr "응답 직렬과"

#: ../../response.rst:6
msgid ""
"If the endpoint returns a `Response` object this response will be used as"
" is."
msgstr "엔드포인트가 `Response` 객체를 반환할 경우 이 응답이 그대로 사용된다."

#: ../../response.rst:8
msgid ""
"Otherwise, and by default and if the specification defines that an "
"endpoint produces only JSON, connexion will automatically serialize the "
"return value for you and set the right content type in the HTTP header."
msgstr ""
"아니면, 엔드포인트가 JSON만 반환하도록 스펙(specification) 정의되어 있다면, 이것은 "
"자동적으로 리턴값을 직렬화 하고, 알맞은 HTTP header content type을 설정한다."

#: ../../response.rst:12
msgid ""
"If the endpoint produces a single non-JSON mimetype then Connexion will "
"automatically set the right content type in the HTTP header."
msgstr ""
"엔드 포인트가 단일 JSON이 아닌 MIME 타입을 생성하면 Connexion은 자동으로 알맞은 HTTP header content type을 설정한다."

#: ../../response.rst:16
msgid "Customizing JSON encoder"
msgstr "사용자 정의 JSON encoder"

#: ../../response.rst:18
msgid ""
"Connexion allows you to customize the `JSONEncoder` class in the Flask "
"app instance `json_encoder` (`connexion.App:app`). If you wanna reuse the"
" Connexion's date-time serialization, inherit your custom encoder from "
"`connexion.apps.flask_app.FlaskJSONEncoder`."
msgstr ""
"Connexion은 플라스크 앱 인스턴스 안에 있는 `json_encoder` (`connexion.App:app`) 의 `JSONEncoder` 클래스를 "
"사용자 정의 할 수 있게 한다. 만약 Connexion의 date-time 직렬화를 재사용하고 싶다면, "
"`connexion.apps.flask_app.FlaskJSONEncoder`\ 사용자 인코더를 상속한다."

#: ../../response.rst:24
msgid "Returning status codes"
msgstr "상태 코드 반환"

#: ../../response.rst:25
msgid "There are two ways of returning a specific status code."
msgstr "지정한 상태 코드(status code)를 반환 할 수 있는 두가지 방법이 있다."

#: ../../response.rst:27 ../../response.rst:40
msgid "One way is to return a `Response` object that will be used unchanged."
msgstr "한 가지 방법은 변경되지 않고 사용될 `Response`\ 객체를 반환하는 것이다."

#: ../../response.rst:29
msgid ""
"The other is returning it as a second return value in the response. For "
"example"
msgstr "다른 방법은 반환값 안의 두번째 값을 상태 값으로 반환한다. 아래 예제를 참조."

#: ../../response.rst:37
msgid "Returning Headers"
msgstr "헤더 반환"

#: ../../response.rst:38
msgid "There are two ways to return headers from your endpoints."
msgstr "당신의 엔드포인트에서 헤더(headers)를 반환하는 두 가지 방법이 있다."

#: ../../response.rst:42
msgid ""
"The other is returning a dict with the header values as the third return "
"value in the response:"
msgstr "다른 방법은 반환값 안의 세 번째 값에 헤더 값들을 포함한 사전 객체를 반환하는 것이다:"

#: ../../response.rst:45
msgid "For example"
msgstr "예를 들어"

#: ../../response.rst:54
msgid "Response Validation"
msgstr "응답 검증"

#: ../../response.rst:55
msgid ""
"While, by default Connexion doesn't validate the responses it's possible "
"to do so by opting in when adding the API:"
msgstr ""
"기본적인 Connexion 설정은 응답에 대한 검증을 하지 않는다. API를 추가하면서 "
"옵션을 설정함으로서 검증과정을 할 수 있다."

#: ../../response.rst:66
msgid ""
"This will validate all the responses using `jsonschema` and is specially "
"useful during development."
msgstr ""
"`jsonschema`\ 을 사용하여 모든 응답들을 검증한다. 이것은 특히 개발 과정에서 유용하다."

#: ../../response.rst:71
msgid "Custom Validator"
msgstr "사용자 정의 검증기"

#: ../../response.rst:73
msgid ""
"By default, response body contents are validated against OpenAPI schema "
"via ``connexion.decorators.response.ResponseValidator``, if you want to "
"change the validation, you can override the default class with:"
msgstr "기본적으로, 응답 body contents는 ``connexion.decorators.response.ResponseValidator``\ 의 OpenAPI 스키마를 통해 "
"검증되어진다. 만약 이 검증을 변경하고 싶다면 이 기본 클래스를 오버라이드 할 수 있다:"

#: ../../response.rst:87
msgid "Error Handling"
msgstr "에러 핸들링"

#: ../../response.rst:88
msgid ""
"By default connexion error messages are JSON serialized according to "
"`Problem Details for HTTP APIs`_"
msgstr ""
"Connexion의 에러 메시지들은 `Problem Details for HTTP APIs`_\ 에 나와있는 것처럼 JSON 직렬화 된다."

#: ../../response.rst:91
msgid "Application can return errors using ``connexion.problem``."
msgstr "``connexion.problem``\ 을 통해 어플리케이션은 에러를 반환할 수 있다."

